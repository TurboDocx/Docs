#!/usr/bin/env python3

import requests
import json
import uuid
from datetime import datetime
from flask import Flask, request, jsonify, Response
import io

# Configuration - Update these values
API_TOKEN = "YOUR_API_TOKEN"
ORG_ID = "YOUR_ORGANIZATION_ID"
BASE_URL = "https://api.turbodocx.com"

app = Flask(__name__)

def generate_deliverable(template_id, deliverable_data):
    """
    Final Step: Generate Deliverable (Both Paths Converge Here)
    Generate a deliverable document from template with variable substitution
    """
    url = f"{BASE_URL}/deliverable"

    print('Generating deliverable...')
    print(f'Template ID: {template_id}')
    print(f'Deliverable Name: {deliverable_data["name"]}')
    print(f'Variables: {len(deliverable_data["variables"])}')

    headers = {
        'Authorization': f'Bearer {API_TOKEN}',
        'x-rapiddocx-org-id': ORG_ID,
        'User-Agent': 'TurboDocx API Client',
        'Content-Type': 'application/json'
    }

    try:
        response = requests.post(url, json=deliverable_data, headers=headers)
        response.raise_for_status()

        # Parse JSON response
        result = response.json()
        deliverable = result['data']['results']['deliverable']

        print('‚úÖ Deliverable generated successfully!')
        print(f'Deliverable ID: {deliverable["id"]}')
        print(f'Created by: {deliverable["createdBy"]}')
        print(f'Created on: {deliverable["createdOn"]}')
        print(f'Template ID: {deliverable["templateId"]}')

        return deliverable

    except requests.exceptions.RequestException as e:
        error_msg = f"Deliverable generation failed: {str(e)}"
        if hasattr(e, 'response') and e.response is not None:
            try:
                error_data = e.response.json()
                error_msg += f" - {error_data}"
            except:
                error_msg += f" - {e.response.text}"
        print(error_msg)
        raise

def download_deliverable(deliverable_id, filename):
    """Download the generated deliverable file"""
    print(f'Downloading file: {filename}')

    url = f"{BASE_URL}/deliverable/file/{deliverable_id}"

    headers = {
        'Authorization': f'Bearer {API_TOKEN}',
        'x-rapiddocx-org-id': ORG_ID,
        'User-Agent': 'TurboDocx API Client'
    }

    try:
        response = requests.get(url, headers=headers, stream=True)
        response.raise_for_status()

        print(f'‚úÖ File ready for download: {filename}')

        content_type = response.headers.get('Content-Type', 'N/A')
        content_length = response.headers.get('Content-Length', 'N/A')

        print(f'üìÅ Content-Type: {content_type}')
        print(f'üìä Content-Length: {content_length} bytes')

        # In a real application, you would save the file
        # with open(filename, 'wb') as f:
        #     for chunk in response.iter_content(chunk_size=8192):
        #         f.write(chunk)

        return {
            'filename': filename,
            'contentType': content_type,
            'contentLength': content_length,
            'downloadStream': response.content
        }

    except requests.exceptions.RequestException as e:
        error_msg = f"Download failed: {str(e)}"
        if hasattr(e, 'response') and e.response is not None:
            try:
                error_data = e.response.json()
                error_msg += f" - {error_data}"
            except:
                error_msg += f" - {e.response.text}"
        print(error_msg)
        raise

def create_simple_variables():
    """Create complex variable structures for testing"""
    return [
        {
            'mimeType': 'text',
            'name': 'Employee Name',
            'placeholder': '{EmployeeName}',
            'text': 'John Smith',
            'allowRichTextInjection': 0,
            'autogenerated': False,
            'count': 1,
            'order': 1,
            'subvariables': [
                {
                    'placeholder': '{EmployeeName.Title}',
                    'text': 'Senior Software Engineer'
                },
                {
                    'placeholder': '{EmployeeName.StartDate}',
                    'text': 'January 15, 2024'
                }
            ],
            'metadata': {
                'department': 'Engineering',
                'level': 'Senior'
            },
            'aiPrompt': 'Generate a professional job description for a senior software engineer role'
        },
        {
            'mimeType': 'text',
            'name': 'Company Information',
            'placeholder': '{CompanyInfo}',
            'text': 'TechCorp Solutions Inc.',
            'allowRichTextInjection': 1,
            'autogenerated': False,
            'count': 1,
            'order': 2,
            'subvariables': [
                {
                    'placeholder': '{CompanyInfo.Address}',
                    'text': '123 Innovation Drive, Tech City, TC 12345'
                },
                {
                    'placeholder': '{CompanyInfo.Phone}',
                    'text': '(555) 123-4567'
                }
            ],
            'metadata': {},
            'aiPrompt': ''
        },
        {
            'mimeType': 'text',
            'name': 'Project Assignments',
            'placeholder': '{ProjectAssignments}',
            'text': 'Multiple ongoing projects',
            'allowRichTextInjection': 0,
            'autogenerated': False,
            'count': 3,
            'order': 3,
            'subvariables': [],
            'variableStack': {
                '0': {
                    'text': 'Project Alpha - Backend Development',
                    'subvariables': [
                        {
                            'placeholder': '{ProjectAssignments.Duration}',
                            'text': '6 months'
                        },
                        {
                            'placeholder': '{ProjectAssignments.Priority}',
                            'text': 'High'
                        }
                    ]
                },
                '1': {
                    'text': 'Project Beta - API Integration',
                    'subvariables': [
                        {
                            'placeholder': '{ProjectAssignments.Duration}',
                            'text': '3 months'
                        },
                        {
                            'placeholder': '{ProjectAssignments.Priority}',
                            'text': 'Medium'
                        }
                    ]
                },
                '2': {
                    'text': 'Project Gamma - Code Review',
                    'subvariables': [
                        {
                            'placeholder': '{ProjectAssignments.Duration}',
                            'text': 'Ongoing'
                        },
                        {
                            'placeholder': '{ProjectAssignments.Priority}',
                            'text': 'Low'
                        }
                    ]
                }
            },
            'metadata': {
                'totalProjects': 3,
                'estimatedHours': 1200
            },
            'aiPrompt': 'Create detailed project descriptions for software development initiatives'
        },
        {
            'mimeType': 'text',
            'name': 'Benefits Package',
            'placeholder': '{BenefitsPackage}',
            'text': 'Comprehensive benefits including health, dental, vision, and 401k',
            'allowRichTextInjection': 1,
            'autogenerated': False,
            'count': 1,
            'order': 4,
            'subvariables': [
                {
                    'placeholder': '{BenefitsPackage.HealthInsurance}',
                    'text': 'Full coverage health insurance with $500 deductible'
                },
                {
                    'placeholder': '{BenefitsPackage.PTO}',
                    'text': '25 days paid time off annually'
                },
                {
                    'placeholder': '{BenefitsPackage.Retirement}',
                    'text': '401k with 6% company match'
                }
            ],
            'metadata': {
                'packageValue': '$15,000 annually',
                'effective': 'First day of employment'
            },
            'aiPrompt': 'Outline a competitive benefits package for a senior software engineer'
        }
    ]

def create_deliverable_data(template_id):
    """Create example deliverable data with complex variables"""
    now = datetime.utcnow().isoformat() + 'Z'

    return {
        'templateId': template_id,
        'name': 'Contract - John Smith',
        'description': 'Employment contract for new senior software engineer',
        'variables': create_simple_variables(),
        'tags': ['hr', 'contract', 'employee', 'engineering'],
        'fonts': '[{"name":"Arial","usage":269}]',
        'defaultFont': 'Arial',
        'replaceFonts': True,
        'metadata': {
            'sessions': [
                {
                    'id': str(uuid.uuid4()),
                    'starttime': now,
                    'endtime': now
                }
            ],
            'createdBy': 'HR Department',
            'documentType': 'Employment Contract',
            'version': 'v1.0'
        }
    }

# Flask route handlers
@app.route('/generate-deliverable', methods=['POST'])
def generate_deliverable_endpoint():
    """Generate deliverable endpoint"""
    try:
        data = request.get_json()

        if not data or 'templateId' not in data:
            return jsonify({
                'error': 'templateId is required'
            }), 400

        template_id = data['templateId']

        # Use provided data or create default data
        deliverable_data = data.get('deliverableData')
        if not deliverable_data:
            deliverable_data = create_deliverable_data(template_id)

        deliverable = generate_deliverable(template_id, deliverable_data)

        return jsonify({
            'success': True,
            'message': 'Deliverable generated successfully',
            'data': deliverable
        })

    except Exception as e:
        app.logger.error(f'Error generating deliverable: {str(e)}')
        return jsonify({
            'error': 'Deliverable generation failed',
            'message': str(e)
        }), 500

@app.route('/download-deliverable/<deliverable_id>', methods=['GET'])
def download_deliverable_endpoint(deliverable_id):
    """Download deliverable endpoint"""
    try:
        filename = request.args.get('filename', f'deliverable-{deliverable_id}.docx')

        download_info = download_deliverable(deliverable_id, filename)

        # Create response with file stream
        response = Response(
            download_info['downloadStream'],
            mimetype=download_info['contentType']
        )
        response.headers['Content-Disposition'] = f'attachment; filename="{filename}"'

        if download_info['contentLength'] and download_info['contentLength'] != 'N/A':
            response.headers['Content-Length'] = download_info['contentLength']

        return response

    except Exception as e:
        app.logger.error(f'Error downloading deliverable: {str(e)}')
        return jsonify({
            'error': 'Download failed',
            'message': str(e)
        }), 500

@app.route('/complete-workflow', methods=['POST'])
def complete_workflow_endpoint():
    """Complete generation workflow endpoint"""
    try:
        data = request.get_json()

        if not data or 'templateId' not in data:
            return jsonify({
                'error': 'templateId is required'
            }), 400

        template_id = data['templateId']
        custom_variables = data.get('customVariables')

        # Create deliverable data
        deliverable_data = create_deliverable_data(template_id)

        # Override variables if custom ones provided
        if custom_variables and isinstance(custom_variables, list):
            deliverable_data['variables'] = custom_variables

        # Generate deliverable
        print('=== Generating Deliverable ===')
        deliverable = generate_deliverable(template_id, deliverable_data)

        # Get download info (but don't actually download in this example)
        print('\n=== Getting Download Info ===')
        download_url = f"{BASE_URL}/deliverable/file/{deliverable['id']}"

        return jsonify({
            'success': True,
            'message': 'Complete workflow executed successfully',
            'data': {
                'deliverable': deliverable,
                'downloadUrl': download_url,
                'downloadEndpoint': f"/download-deliverable/{deliverable['id']}",
                'summary': {
                    'deliverableId': deliverable['id'],
                    'templateId': deliverable['templateId'],
                    'createdBy': deliverable['createdBy'],
                    'createdOn': deliverable['createdOn']
                }
            }
        })

    except Exception as e:
        app.logger.error(f'Error in complete workflow: {str(e)}')
        return jsonify({
            'error': 'Complete workflow failed',
            'message': str(e)
        }), 500

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({
        'status': 'healthy',
        'service': 'deliverable-generator'
    })

@app.route('/generator-info', methods=['GET'])
def generator_info():
    """Service information endpoint"""
    return jsonify({
        'service': 'TurboDocx Deliverable Generator Service',
        'endpoints': {
            'POST /generate-deliverable': 'Generate a deliverable from template',
            'GET /download-deliverable/<deliverable_id>': 'Download generated deliverable file',
            'POST /complete-workflow': 'Complete generation and download workflow',
            'GET /health': 'Service health check',
            'GET /generator-info': 'Service information'
        },
        'configuration': {
            'baseUrl': BASE_URL,
            'hasToken': bool(API_TOKEN and API_TOKEN != 'YOUR_API_TOKEN'),
            'hasOrgId': bool(ORG_ID and ORG_ID != 'YOUR_ORGANIZATION_ID')
        }
    })

def demonstrate_generation():
    """Example usage function"""
    try:
        print('=== Final Step: Generate Deliverable ===')

        # This would come from either Path A (upload) or Path B (browse/select)
        template_id = "0b1099cf-d7b9-41a4-822b-51b68fd4885a"

        deliverable_data = create_deliverable_data(template_id)
        deliverable = generate_deliverable(template_id, deliverable_data)

        # Download the generated file
        print('\n=== Download Generated File ===')
        download_info = download_deliverable(deliverable['id'], f"{deliverable['name']}.docx")

        print('\n=== Generation Complete ===')
        print('Deliverable generated and download info retrieved successfully')

        return {
            'deliverable': deliverable,
            'downloadInfo': download_info
        }

    except Exception as e:
        print(f'Generation demonstration failed: {str(e)}')
        exit(1)

if __name__ == '__main__':
    import sys
    import os

    if '--demo' in sys.argv:
        # Run demonstration
        demonstrate_generation()
    else:
        # Start Flask server
        port = int(os.environ.get('PORT', 5003))
        host = os.environ.get('HOST', '0.0.0.0')

        print('üöÄ TurboDocx Deliverable Generator Service started')
        print(f'üì° Server listening on http://{host}:{port}')
        print('\nAvailable endpoints:')
        print(f'  POST http://{host}:{port}/generate-deliverable')
        print(f'  GET  http://{host}:{port}/download-deliverable/<deliverable_id>')
        print(f'  POST http://{host}:{port}/complete-workflow')
        print(f'  GET  http://{host}:{port}/health')
        print(f'  GET  http://{host}:{port}/generator-info')

        app.run(host=host, port=port, debug=False)