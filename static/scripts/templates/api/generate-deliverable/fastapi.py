#!/usr/bin/env python3

import requests
import json
import uuid
from datetime import datetime
from typing import Optional, List, Dict, Any
from fastapi import FastAPI, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
import uvicorn
import io

# Configuration - Update these values
API_TOKEN = "YOUR_API_TOKEN"
ORG_ID = "YOUR_ORGANIZATION_ID"
BASE_URL = "https://api.turbodocx.com"

app = FastAPI(
    title="TurboDocx Deliverable Generator Service",
    description="FastAPI service for generating deliverables from templates using TurboDocx API",
    version="1.0.0"
)

class Variable(BaseModel):
    mimeType: str
    name: str
    placeholder: str
    text: str
    allowRichTextInjection: int
    autogenerated: bool
    count: int
    order: int
    subvariables: Optional[List[Dict[str, str]]] = []
    variableStack: Optional[Dict[str, Any]] = {}
    metadata: Optional[Dict[str, Any]] = {}
    aiPrompt: Optional[str] = ""

class Session(BaseModel):
    id: str
    starttime: str
    endtime: str

class Metadata(BaseModel):
    sessions: List[Session]
    createdBy: str
    documentType: str
    version: str

class DeliverableData(BaseModel):
    templateId: str
    name: str
    description: str
    variables: List[Variable]
    tags: List[str]
    fonts: str
    defaultFont: str
    replaceFonts: bool
    metadata: Metadata

class GenerateRequest(BaseModel):
    templateId: str
    deliverableData: Optional[DeliverableData] = None

class WorkflowRequest(BaseModel):
    templateId: str
    customVariables: Optional[List[Variable]] = None

class GenerateResponse(BaseModel):
    success: bool
    message: str
    data: dict

class WorkflowResponse(BaseModel):
    success: bool
    message: str
    data: dict

class ConfigurationInfo(BaseModel):
    baseUrl: str
    hasToken: bool
    hasOrgId: bool

class ServiceInfo(BaseModel):
    service: str
    endpoints: dict
    configuration: ConfigurationInfo

def generate_deliverable(template_id: str, deliverable_data: dict) -> dict:
    """
    Final Step: Generate Deliverable (Both Paths Converge Here)
    Generate a deliverable document from template with variable substitution
    """
    url = f"{BASE_URL}/deliverable"

    print('Generating deliverable...')
    print(f'Template ID: {template_id}')
    print(f'Deliverable Name: {deliverable_data["name"]}')
    print(f'Variables: {len(deliverable_data["variables"])}')

    headers = {
        'Authorization': f'Bearer {API_TOKEN}',
        'x-rapiddocx-org-id': ORG_ID,
        'User-Agent': 'TurboDocx API Client',
        'Content-Type': 'application/json'
    }

    try:
        response = requests.post(url, json=deliverable_data, headers=headers)
        response.raise_for_status()

        # Parse JSON response
        result = response.json()
        deliverable = result['data']['results']['deliverable']

        print('✅ Deliverable generated successfully!')
        print(f'Deliverable ID: {deliverable["id"]}')
        print(f'Created by: {deliverable["createdBy"]}')
        print(f'Created on: {deliverable["createdOn"]}')
        print(f'Template ID: {deliverable["templateId"]}')

        return deliverable

    except requests.exceptions.RequestException as e:
        error_msg = f"Deliverable generation failed: {str(e)}"
        if hasattr(e, 'response') and e.response is not None:
            try:
                error_data = e.response.json()
                error_msg += f" - {error_data}"
            except:
                error_msg += f" - {e.response.text}"
        print(error_msg)
        raise

def download_deliverable(deliverable_id: str, filename: str) -> dict:
    """Download the generated deliverable file"""
    print(f'Downloading file: {filename}')

    url = f"{BASE_URL}/deliverable/file/{deliverable_id}"

    headers = {
        'Authorization': f'Bearer {API_TOKEN}',
        'x-rapiddocx-org-id': ORG_ID,
        'User-Agent': 'TurboDocx API Client'
    }

    try:
        response = requests.get(url, headers=headers, stream=True)
        response.raise_for_status()

        print(f'✅ File ready for download: {filename}')

        content_type = response.headers.get('Content-Type', 'N/A')
        content_length = response.headers.get('Content-Length', 'N/A')

        print(f'📁 Content-Type: {content_type}')
        print(f'📊 Content-Length: {content_length} bytes')

        # Return response object for streaming
        return {
            'filename': filename,
            'contentType': content_type,
            'contentLength': content_length,
            'response': response
        }

    except requests.exceptions.RequestException as e:
        error_msg = f"Download failed: {str(e)}"
        if hasattr(e, 'response') and e.response is not None:
            try:
                error_data = e.response.json()
                error_msg += f" - {error_data}"
            except:
                error_msg += f" - {e.response.text}"
        print(error_msg)
        raise

def create_complex_variables() -> List[dict]:
    """Create complex variable structures for testing"""
    return [
        {
            'mimeType': 'text',
            'name': 'Employee Name',
            'placeholder': '{EmployeeName}',
            'text': 'John Smith',
            'allowRichTextInjection': 0,
            'autogenerated': False,
            'count': 1,
            'order': 1,
            'subvariables': [
                {
                    'placeholder': '{EmployeeName.Title}',
                    'text': 'Senior Software Engineer'
                },
                {
                    'placeholder': '{EmployeeName.StartDate}',
                    'text': 'January 15, 2024'
                }
            ],
            'metadata': {
                'department': 'Engineering',
                'level': 'Senior'
            },
            'aiPrompt': 'Generate a professional job description for a senior software engineer role'
        },
        {
            'mimeType': 'text',
            'name': 'Company Information',
            'placeholder': '{CompanyInfo}',
            'text': 'TechCorp Solutions Inc.',
            'allowRichTextInjection': 1,
            'autogenerated': False,
            'count': 1,
            'order': 2,
            'subvariables': [
                {
                    'placeholder': '{CompanyInfo.Address}',
                    'text': '123 Innovation Drive, Tech City, TC 12345'
                },
                {
                    'placeholder': '{CompanyInfo.Phone}',
                    'text': '(555) 123-4567'
                }
            ],
            'metadata': {},
            'aiPrompt': ''
        },
        {
            'mimeType': 'text',
            'name': 'Project Assignments',
            'placeholder': '{ProjectAssignments}',
            'text': 'Multiple ongoing projects',
            'allowRichTextInjection': 0,
            'autogenerated': False,
            'count': 3,
            'order': 3,
            'subvariables': [],
            'variableStack': {
                '0': {
                    'text': 'Project Alpha - Backend Development',
                    'subvariables': [
                        {
                            'placeholder': '{ProjectAssignments.Duration}',
                            'text': '6 months'
                        },
                        {
                            'placeholder': '{ProjectAssignments.Priority}',
                            'text': 'High'
                        }
                    ]
                },
                '1': {
                    'text': 'Project Beta - API Integration',
                    'subvariables': [
                        {
                            'placeholder': '{ProjectAssignments.Duration}',
                            'text': '3 months'
                        },
                        {
                            'placeholder': '{ProjectAssignments.Priority}',
                            'text': 'Medium'
                        }
                    ]
                },
                '2': {
                    'text': 'Project Gamma - Code Review',
                    'subvariables': [
                        {
                            'placeholder': '{ProjectAssignments.Duration}',
                            'text': 'Ongoing'
                        },
                        {
                            'placeholder': '{ProjectAssignments.Priority}',
                            'text': 'Low'
                        }
                    ]
                }
            },
            'metadata': {
                'totalProjects': 3,
                'estimatedHours': 1200
            },
            'aiPrompt': 'Create detailed project descriptions for software development initiatives'
        },
        {
            'mimeType': 'text',
            'name': 'Benefits Package',
            'placeholder': '{BenefitsPackage}',
            'text': 'Comprehensive benefits including health, dental, vision, and 401k',
            'allowRichTextInjection': 1,
            'autogenerated': False,
            'count': 1,
            'order': 4,
            'subvariables': [
                {
                    'placeholder': '{BenefitsPackage.HealthInsurance}',
                    'text': 'Full coverage health insurance with $500 deductible'
                },
                {
                    'placeholder': '{BenefitsPackage.PTO}',
                    'text': '25 days paid time off annually'
                },
                {
                    'placeholder': '{BenefitsPackage.Retirement}',
                    'text': '401k with 6% company match'
                }
            ],
            'metadata': {
                'packageValue': '$15,000 annually',
                'effective': 'First day of employment'
            },
            'aiPrompt': 'Outline a competitive benefits package for a senior software engineer'
        }
    ]

def create_deliverable_data(template_id: str) -> dict:
    """Create example deliverable data with complex variables"""
    now = datetime.utcnow().isoformat() + 'Z'

    return {
        'templateId': template_id,
        'name': 'Employee Contract - John Smith',
        'description': 'Employment contract for new senior software engineer',
        'variables': create_complex_variables(),
        'tags': ['hr', 'contract', 'employee', 'engineering'],
        'fonts': '[{"name":"Arial","usage":269}]',
        'defaultFont': 'Arial',
        'replaceFonts': True,
        'metadata': {
            'sessions': [
                {
                    'id': str(uuid.uuid4()),
                    'starttime': now,
                    'endtime': now
                }
            ],
            'createdBy': 'HR Department',
            'documentType': 'Employment Contract',
            'version': 'v1.0'
        }
    }

# FastAPI route handlers
@app.post("/generate-deliverable", response_model=GenerateResponse)
async def generate_deliverable_endpoint(request: GenerateRequest):
    """Generate deliverable from template"""
    try:
        # Use provided data or create default data
        if request.deliverableData:
            deliverable_data = request.deliverableData.dict()
        else:
            deliverable_data = create_deliverable_data(request.templateId)

        deliverable = generate_deliverable(request.templateId, deliverable_data)

        return GenerateResponse(
            success=True,
            message="Deliverable generated successfully",
            data=deliverable
        )

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Deliverable generation failed: {str(e)}")

@app.get("/download-deliverable/{deliverable_id}")
async def download_deliverable_endpoint(deliverable_id: str, filename: Optional[str] = None):
    """Download generated deliverable file"""
    try:
        if not filename:
            filename = f'deliverable-{deliverable_id}.docx'

        download_info = download_deliverable(deliverable_id, filename)

        # Create streaming response
        def generate_file_stream():
            for chunk in download_info['response'].iter_content(chunk_size=8192):
                yield chunk

        headers = {
            'Content-Disposition': f'attachment; filename="{filename}"'
        }

        if download_info['contentLength'] and download_info['contentLength'] != 'N/A':
            headers['Content-Length'] = download_info['contentLength']

        return StreamingResponse(
            generate_file_stream(),
            media_type=download_info['contentType'],
            headers=headers
        )

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Download failed: {str(e)}")

@app.post("/complete-workflow", response_model=WorkflowResponse)
async def complete_workflow_endpoint(request: WorkflowRequest):
    """Complete generation and download workflow"""
    try:
        # Create deliverable data
        deliverable_data = create_deliverable_data(request.templateId)

        # Override variables if custom ones provided
        if request.customVariables:
            # Convert Pydantic models to dict
            deliverable_data['variables'] = [var.dict() if hasattr(var, 'dict') else var for var in request.customVariables]

        # Generate deliverable
        print('=== Generating Deliverable ===')
        deliverable = generate_deliverable(request.templateId, deliverable_data)

        # Get download info (but don't actually download in this example)
        print('\n=== Getting Download Info ===')
        download_url = f"{BASE_URL}/deliverable/file/{deliverable['id']}"

        return WorkflowResponse(
            success=True,
            message="Complete workflow executed successfully",
            data={
                'deliverable': deliverable,
                'downloadUrl': download_url,
                'downloadEndpoint': f"/download-deliverable/{deliverable['id']}",
                'summary': {
                    'deliverableId': deliverable['id'],
                    'templateId': deliverable['templateId'],
                    'createdBy': deliverable['createdBy'],
                    'createdOn': deliverable['createdOn']
                }
            }
        )

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Complete workflow failed: {str(e)}")

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "deliverable-generator"
    }

@app.get("/generator-info", response_model=ServiceInfo)
async def generator_info():
    """Service information endpoint"""
    return ServiceInfo(
        service="TurboDocx Deliverable Generator Service",
        endpoints={
            "POST /generate-deliverable": "Generate a deliverable from template",
            "GET /download-deliverable/{deliverable_id}": "Download generated deliverable file",
            "POST /complete-workflow": "Complete generation and download workflow",
            "GET /health": "Service health check",
            "GET /generator-info": "Service information",
            "GET /docs": "Interactive API documentation",
            "GET /redoc": "Alternative API documentation"
        },
        configuration=ConfigurationInfo(
            baseUrl=BASE_URL,
            hasToken=bool(API_TOKEN and API_TOKEN != 'YOUR_API_TOKEN'),
            hasOrgId=bool(ORG_ID and ORG_ID != 'YOUR_ORGANIZATION_ID')
        )
    )

def demonstrate_generation():
    """Example usage function"""
    try:
        print('=== Final Step: Generate Deliverable ===')

        # This would come from either Path A (upload) or Path B (browse/select)
        template_id = "0b1099cf-d7b9-41a4-822b-51b68fd4885a"

        deliverable_data = create_deliverable_data(template_id)
        deliverable = generate_deliverable(template_id, deliverable_data)

        # Get download info (but don't actually download in demo)
        print('\n=== Download Info ===')
        print(f'Download URL: {BASE_URL}/deliverable/file/{deliverable["id"]}')

        print('\n=== Generation Complete ===')
        print('Deliverable generated successfully')

        return {
            'deliverable': deliverable,
            'downloadUrl': f'{BASE_URL}/deliverable/file/{deliverable["id"]}'
        }

    except Exception as e:
        print(f'Generation demonstration failed: {str(e)}')
        exit(1)

if __name__ == '__main__':
    import sys
    import os

    if '--demo' in sys.argv:
        # Run demonstration
        demonstrate_generation()
    else:
        # Start FastAPI server
        port = int(os.environ.get('PORT', 8003))
        host = os.environ.get('HOST', '0.0.0.0')

        print('🚀 TurboDocx Deliverable Generator Service started')
        print(f'📡 Server listening on http://{host}:{port}')
        print('\nAvailable endpoints:')
        print(f'  POST http://{host}:{port}/generate-deliverable')
        print(f'  GET  http://{host}:{port}/download-deliverable/{{deliverable_id}}')
        print(f'  POST http://{host}:{port}/complete-workflow')
        print(f'  GET  http://{host}:{port}/health')
        print(f'  GET  http://{host}:{port}/generator-info')
        print(f'  GET  http://{host}:{port}/docs (Interactive API docs)')
        print(f'  GET  http://{host}:{port}/redoc (Alternative API docs)')

        uvicorn.run(app, host=host, port=port)